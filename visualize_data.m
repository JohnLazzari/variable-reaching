% visualize_data.m
% This script helps to visualize and save data. It has two basic types of
% functionality: 
% 1) visualize neural population by trial/reach, and 
% 2) visualize single neurons across all trials/reaches. 
% Input: This script loads data files generated by the clean_data.m script
% Output: This script (part #1) generates a new data structure called
% Data_win ("windowed data") which can be saved and used for other types of
% analysis. 
%
% code by Patrick Lawlor (Kording lab) @ Northwestern University, circa 2017
% data uploaded to CRCNS was collected by Matthew Perich (Miller lab) @
% Northwestern University, circa 2015

%% Load scripts

addpath(genpath('./processing/'))

%% Load data

fpath = './source_data/processed/';
fname = 'MM_S1_processed.mat'; % Monkey M (MM), session 1; PMd and M1
% fname = 'MT_S1_processed.mat'; % Monkey T (MT), session 1; PMd only
% fname = 'MT_S2_processed.mat'; % Monkey T (MT), session 2; PMd only
% fname = 'MT_S3_processed.mat'; % Monkey T (MT), session 3; PMd only

load([fpath fname])

M1_present = isfield(Data,'neural_data_M1'); % Check for existence of M1 data

num_units_PMd = size(Data(1).neural_data_PMd{1},1);
if M1_present
    num_units_M1 = size(Data(1).neural_data_M1{1},1);
end

num_trials_total = length(Data(1).neural_data_PMd); % "trial" is used loosely here; refers to trial or reach dependong on the data used

%% Part 1 - visualize population activity by trial - ABOUT

% This section of the code allows you to visualize all of the recorded
% neurons for each trial at the same time.
%
% Quantities visualized:
% -X vs Y position of the reach
% -X and Y velocities vs time
% -Speed vs time
% -Raster of M1 spikes
% -Raster of PMd spikes
%
% A number of parameters can be set by the user (detailed below), including
% which neurons to visualize, which reach directions to visualize, which
% time window surrounding the reach to visualize, which event to align to
% (movement onset, reach target appearance), and a number of more minor
% things.

%% Part 1 - visualize population activity by trial - USER INPUTS

block_num = 1; % Always use block 1
dt = 0.01; % in seconds. Default 0.01

target_loc = [-7:2:7]*pi/8; % Choose reaches towards given angle. Range of input: -pi:pi. Selects a range of reaches (of size pi/4) centered on each direction specified here.

% trials_desired = 1:num_trials_total; % All trials
trials_desired = [1:10]; % A subset of trials, if desired
trials_bad = []; % Can exclude trials if desired

trials = setdiff(trials_desired,trials_bad);

plot_figs = 1; % Visualize data associated with each trial
save_data = 0; % Store data in a struct for later saving (Data_win)

neurons_PMd = 1:num_units_PMd;
if M1_present
    neurons_M1 = 1:num_units_M1;    
end

sort_nrn_by_PD = 0; % Can sort neurons by PD within raster if that information is available, which it isn't by default. 

thresh_speed = 8; % Speed at which reach start is defined.
min_speed = 12; % Minimum value of the maximum speed a reach must achieve to qualify as a reach; discards wimpy reaches. Quality control. Default 12.

time_window_sec = [-0.6,0.4]; % With respect to speed threshold crossing, in seconds. I.e., [-0.6,0,4] grabs data 600 ms before and 400 ms after speed threshold crossing. NaN here allows you to use entire available window.
time_window_bin = round(time_window_sec/dt); % Convert to bins
time_window = [time_window_bin(1):time_window_bin(2)]; % Make array; will be array of bins relative to speed threshold crossing

enforce_window_len = 0; % Whether data window must be same size as time_window

from_move_start = 1; % Align data from movement start (i.e., speed threshold crossing)
from_cue_on = 0; % Align data from cue on

min_rxn_time = 0.1; % Minimum reaction time of reach relative to reach target appearance. Default 0.1 sec.

wind_acc = 0.1; % Amount of time in sec after speed threshold crossing that reach speed must be constant or accelerating. Quality control. Default 0.1.
wind_acc_tol = 0.5; % Percentage of bins within wind_acc that must be accelerating. Quality control. Default 0.5.

%% Part 1 - visualize population activity by trial - CODE

% Choose trials with a given target location
trials_temp = zeros(num_trials_total,1);
trials_temp(trials) = 1;

temp = cell2mat(Data.reach_dir);
target_locs_rep = repmat(temp,[1 length(target_loc)]);
cond = abs(target_locs_rep - repmat(target_loc,[num_trials_total 1])); % Define condition for including reach: reach within pi/8 of desired direction (more below)
trials_temp_target_loc = any((cond<pi/8),2); % .39 is 2pi/8/2. I.e., half of a 2pi/8 bin in either direction
trials = find(trials_temp.*trials_temp_target_loc); % Find trials meeting this condition

% Initialize storage variables
if M1_present
    spikes_M1 = cell(length(trials),length(neurons_M1));
end
spikes_PMd = cell(length(trials),length(neurons_PMd));
movement_cov = cell(length(trials),1);
kinematics = cell(length(trials),1);
go_cue = cell(length(trials),1);
outer_target = cell(length(trials),1);
target_dir = cell(length(trials),1);
target_dir_num = cell(length(trials),1);

% Opportunity to sort neuron order in the plotted raster, e.g., by 
% preferred direction, if desired. Default is no sorting scheme. 
idx_sort_PMd = 1:num_units_PMd;
if M1_present
    idx_sort_M1 = 1:num_units_M1;
end

for trial_idx = 1:length(trials)
    trial_num = trials(trial_idx);
    num_bins = size(Data(block_num).neural_data_PMd{trial_num}(neurons_PMd,:),2);
    
    x_pos = Data(block_num).kinematics{trial_num}(:,1);
    y_pos = Data(block_num).kinematics{trial_num}(:,2);
    x_vel = Data(block_num).kinematics{trial_num}(:,3);
    y_vel = Data(block_num).kinematics{trial_num}(:,4);
    x_acc = Data(block_num).kinematics{trial_num}(:,5);
    y_acc = Data(block_num).kinematics{trial_num}(:,6);
    speed = sqrt(x_vel.^2 + y_vel.^2);
    
    % Get movement onset
    if from_move_start
        if any(speed > thresh_speed)
                idx_target_on = find(Data.target_on{trial_num}); % When the target came on (in bins)
                bins_after_tgt = ceil(min_rxn_time/dt); % Min rxn time (in bins)
                idx_possible = idx_target_on + bins_after_tgt; % Define earliest bin meeting rxn time criteria
                bins_possible = speed*0; % Initialize variable
                bins_possible(idx_possible:end) = 1; % Set which bins are candidates for inclusion
                bins_thresh_cross = (speed > thresh_speed).*(bins_possible); % Find bins that both exceed speed threshold and are after minimum rxn time
                
                if sum(bins_thresh_cross) < 1 % If nothing meets critera, skip trial
                    continue
                end               
                
                bin_align = find(bins_thresh_cross,1); % Set bin to align data to (where speed threshold crossing happens)

        else
            % If no speed meets criteria, skip trial
            continue
        end
    end
    
    % If you want to align data from cue on
    if from_cue_on
        bin_align = find(Data(block_num).target_on{trial_num});
    end
        
    
    % Change plotting time window
    if ~any(isnan(time_window)) % If none of the time window bins are nan
        time_window_trial = time_window + bin_align; % For one reach, define data window relative to alignment bin
%         time_window_trial = 1:num_bins; % For plotting the whole trial
        
        % Do some error checking - exclude bins that are before or after
        % the available neural data
        time_window_trial(time_window_trial<1) = []; % Set any bins earlier than time window start to empty
        time_window_trial(time_window_trial>num_bins) = []; % Set any bins after neural data end to empty. The number of neural data bins available is num_bins (see above)
    else % Using a nan in the time_window in user inputs allows you to use the whole reach instead of specifying particular window
        time_window_trial = 1:num_bins;
    end
    
    % Exclusion condition: speed must (mostly) monotonically increase for a fixed
    % amount of time - the acceleration window (wind_acc)
    speed_wind_acc = speed(bin_align:(bin_align + round(wind_acc/dt)));
    perc_dec = sum((diff(speed_wind_acc)<0))/length(speed_wind_acc); % Define the percentage of bins with positive acceleration
    if  perc_dec > wind_acc_tol % If percentage is too low, skip trial
        disp(['Trial: ' num2str(trial_num) ' - Reach excluded, did not meet acceleration criterion'])
        continue
    end
    
    % Exclusion condition: reaches that don't meet minimum speed
    if max(speed_wind_acc) < min_speed % If max speed within this window does not meet a minimum value, skip trial
        disp(['Trial: ' num2str(trial_num) ' - Reach excluded, did not meet speed criterion'])
        continue
    end
    
    if plot_figs
        % Open plotting window
        figure('units','normalized','outerposition',[0 0 .4 1])
        
        % Plot X vs Y location of reach
        subplot(6,4,[1 5 9 13 17 21])
        plot(x_pos(time_window_trial),y_pos(time_window_trial))
        axis([-12 12 -12 12])
        axis square
        
        % Plot kinematics vs time
        subplot(6,4,[2 3 4])
        plot(x_vel(time_window_trial),'b'); hold on
        plot(y_vel(time_window_trial),'r'); hold off
        ylim([-30 30])
        xlim([0 length(time_window_trial)])
        title(['Trial: ' num2str(trial_num)])

        % Plot speed vs time
        subplot(6,4,[6 7 8])
        plot(speed(time_window_trial),'LineWidth',2)

        % Plot speed threshold line
        line([0 length(time_window_trial)],[thresh_speed thresh_speed],'Color','g')
        
        % If aligning to movement start, plot line to indicate when speed
        % threshold crossed
        if from_move_start
            thresh_cross_to_plot = find(bins_thresh_cross(time_window_trial),1);
            line([thresh_cross_to_plot thresh_cross_to_plot],[-30 30],'Color','g')
        end
        
        % If aligning to cue on, plot line to indicate when it came on
        if from_cue_on
            bin_cue_on = find(Data(block_num).target_on{trial_num}(time_window_trial));
            line([bin_cue_on bin_cue_on],[-30 30],'Color','g')
        end

        ylim([-5 30])
        xlim([0 length(time_window_trial)])
        
        % Plot PMd neural data
        subplot(6,4,[18 19 20 22 23 24])
        imagesc(Data(block_num).neural_data_PMd{trial_num}(idx_sort_PMd(neurons_PMd),time_window_trial),[0 3])
        xlabel('Time (10ms bins)'), ylabel('PMd N#')
        
        % Plot M1 neural data
        subplot(6,4,[10 11 12 14 15 16])
        if M1_present
            imagesc(Data(block_num).neural_data_M1{trial_num}(idx_sort_M1(neurons_M1),time_window_trial),[0 3])
            ylabel('M1 N#')
        end
        
    end
    
    % Save everything
    if save_data
        spikes_PMd(trial_idx,:) = mat2cell(Data(block_num).neural_data_PMd{trial_num}(neurons_PMd,time_window_trial)',[length(time_window_trial)], [ones(1,length(neurons_PMd))]);
        if M1_present
            spikes_M1(trial_idx,:) = mat2cell(Data(block_num).neural_data_M1{trial_num}(neurons_M1,time_window_trial)',[length(time_window_trial)], [ones(1,length(neurons_M1))]);
        end
        
        % Write data for future use in analysis script - not important for
        % the user
        temp = zeros(size(Data(block_num).neural_data_PMd{trial_num},2),3); % initialize variable
        temp(bin_align,:) = [1 cos(Data.reach_dir{trial_num}) sin(Data.reach_dir{trial_num})]; % set value of 'bin_align' to indicate when movement started and its direction
        
        movement_cov{trial_idx} = temp(time_window_trial,:); % include movement data from time_window
        kinematics{trial_idx} = [x_pos(time_window_trial) y_pos(time_window_trial), ... % include kinematics from time_window
                                    x_vel(time_window_trial) y_vel(time_window_trial), ...
                                    x_acc(time_window_trial) y_acc(time_window_trial)];

        % Write reach direction to file for later use in analysis script -
        % not important for the user
        temp3 = repmat(temp(:,1)*0,[1 3]);
        temp3(1,1) = 1;
        temp3(1,2:3) = [cos(Data.reach_dir{trial_num}) sin(Data.reach_dir{trial_num})];
        target_dir{trial_idx} = Data.reach_dir{trial_num};
        target_dir_num{trial_idx} = round(target_dir{trial_idx}/(pi/8));
        outer_target{trial_idx} = temp3(time_window_trial,:);
        
    end
end

if save_data
    % If enforcing data window length, check trials and exclude those not
    % meeting conditions.
    if enforce_window_len
        full_trial_len = abs(time_window(1)) + abs(abs(time_window(end))) + 1;
        good_trials = cellfun( ...
            @(x)(size(x,1)==full_trial_len), ...
            spikes_PMd(:,1), ...
            'UniformOutput',false);
        good_trials = cell2mat(good_trials);
    else    
        good_trials = cellfun( ...
            @isempty, ...
            spikes_PMd(:,1), ...
            'UniformOutput',false);
        good_trials = ~cell2mat(good_trials);
    end
    
    % Write info to file
    if M1_present
        Data_win(block_num).spikes_M1 = spikes_M1(good_trials,:);
    end
    Data_win(block_num).spikes_PMd = spikes_PMd(good_trials,:);
    Data_win(block_num).movement_cov = movement_cov(good_trials);
    Data_win(block_num).kinematics = kinematics(good_trials);
    Data_win(block_num).go_cue = go_cue(good_trials);
    Data_win(block_num).outer_target = outer_target(good_trials); % The name of this variable is legacy; it just denotes "target on"
    Data_win(block_num).target_dir_num = target_dir_num(good_trials);
    Data_win(block_num).target_dir = target_dir(good_trials);
end

%% Part 2 - visualize single-neuron activity across all trials - ABOUT

% This section of the code allows you to visualize one neuron at a time,
% but for all trials. This is especially useful for looking at how a
% neuron's activity depends on reach direction. This section also fits a
% simple tuning model to the neuron's activity to estimate its preferred
% direction - the direction of reach for which the neuron produces the most
% spikes.
%
% Quantities visualized:
% -Raster of neuron activity, by default sorted by reach direction
% -The total number of spikes for each trial vs reach direction
%
% A number of parameters can be set by the user (detailed below), including
% which neurons to visualize, which reach directions to visualize, which
% time window surrounding the reach to visualize, which event to align to
% (movement onset, reach target appearance), and a number of more minor
% things.

%% Part 2 - visualize single-neuron activity across all trials - USER INPUTS

target_loc = [-7:2:7]*pi/8; % -pi:pi is the input range. Selects a range of reaches of size pi/4 around each entry here.

trials_desired = 1:num_trials_total; % Include all trials by default
trials_bad = []; % Exclude trials if desired
trials_to_use = setdiff(trials_desired,trials_bad);

neurons_M1 = []; % maximum value is num_units_M1
neurons_PMd = [31:40]; % maximum value is num_units_PMd

from_move_start = 1; 
thresh_speed = 8; % If aligning to reach start

from_cue_on = 0;

time_window_sec = [-0.6,0.4]; % With respect to speed threshold crossing, in seconds. I.e., [-0.6,0,4] grabs data 600 ms before and 400 ms after speed threshold crossing. NaN here allows you to use entire available window.
time_window_bin = round(time_window_sec/dt); % Convert to bins
time_window = [time_window_bin(1):time_window_bin(2)]; % Make array; will be array of bins relative to speed threshold crossing

box_reach_st = [-100 100 -100 100]; % To define where reaches must start (e.g., center). [x1 x2 y1 y2], x2>x1,y2>y1; For this data, x [-11,7], y [-7, 11]; default is big in order to encompass all reaches.
min_reach_len = 0;
min_rxn_time = 0.1; % Default value 0.1
dt = 0.01; % Default is 0.01

plot_figs = 1;
sort_trials = 1;

block_num = 1;  % There is only one block for this data

%% Part 2 - visualize single-neuron activity across all trials - CODE

% Choose trials with a given target location
trials_temp = zeros(num_trials_total,1);
trials_temp(trials_to_use) = 1;

% Choose reaches into the right directions
target_locs_temp = cell2mat(Data.reach_dir);
target_locs_rep = repmat(target_locs_temp,[1 length(target_loc)]);
cond = abs(target_locs_rep - repmat(target_loc,[num_trials_total 1]));
trials_temp_target_loc = any(cond<=pi/8,2);

% If you want reaches of a certiain length
reach_lens = cell2mat(Data.reach_len);
trials_reach_len = reach_lens > min_reach_len;

% Choose reaches starting within a certain box  
trials_box = reach_by_st_loc(Data(block_num),box_reach_st);
trials = find(trials_temp.*trials_temp_target_loc.*trials_box.*trials_reach_len);

neurons_all = [neurons_M1 neurons_PMd];

% Initialize
neural_data_cell = cell(length(neurons_all),1);
PD = nan(length(neurons_all),1);

% Loop through each neuron
for nrn_idx = 1:length(neurons_all)
    nrn_num = neurons_all(nrn_idx);
    
    % Choose correct region
    if nrn_idx > length(neurons_M1)
        region = 'PMd';
    else
        region = 'M1';
    end
    
    switch region
        case 'PMd'
            
            num_nrn_PMd = size(Data(block_num).neural_data_PMd{trial_num},1);
            if nrn_num > num_nrn_PMd
                continue
            end
            
            for trial_idx = 1:length(trials)
                trial_num = trials(trial_idx);
                
                Data_struct(trial_idx).data = full(Data(block_num).neural_data_PMd{trial_num}(nrn_num,:));
                Data_struct(trial_idx).align_bin = zeros(1,length(Data_struct(trial_idx).data));

                Data_struct(trial_idx).target_dir = Data(block_num).reach_dir{trial_num}; 
                
                vel_x = Data(block_num).kinematics{trial_num}(:,3);
                vel_y = Data(block_num).kinematics{trial_num}(:,4);
                speed = smooth(sqrt(vel_x.^2 + vel_y.^2));
                
                if from_move_start
                    if any(speed > thresh_speed)
                            % Find reaches meeting requirements
                            idx_target_on = find(Data.target_on{trial_num}); % When the target came on (in bins)
                            bins_after_tgt = ceil(min_rxn_time/dt); % Min rxn time (in bins)
                            idx_possible = idx_target_on + bins_after_tgt; 
                            bins_possible = speed*0;
                            bins_possible(idx_possible:end) = 1;
                            bins_thresh_cross = (speed > thresh_speed).*(bins_possible); % Only keep reach if: crosses speed threshold and happens after cue comes on plus some min rxn time
                            
                            if sum(bins_thresh_cross) < 1
                                continue
                            end
                            
                            bin_align = find(bins_thresh_cross,1); % For when speed threshold is reached; Need to push forward to around rxn time so as not to get end of current movement
                    else
                        continue
                    end
                end
                
                if from_cue_on
                    bin_align = find(Data.target_on{trial_num});
                end
                
                Data_struct(trial_idx).align_bin = bin_align;
            end
        case 'M1'
            num_nrn_M1 = size(Data(block_num).neural_data_M1{trial_num},1);
            if nrn_num > num_nrn_M1
                continue
            end
            
            for trial_idx = 1:length(trials)
                trial_num = trials(trial_idx);
                
                Data_struct(trial_idx).data = full(Data(block_num).neural_data_M1{trial_num}(nrn_num,:));
                Data_struct(trial_idx).align_bin = zeros(1,length(Data_struct(trial_idx).data));
                
                Data_struct(trial_idx).target_dir = Data(block_num).reach_dir{trial_num};
                
                vel_x = Data(block_num).kinematics{trial_num}(:,3);
                vel_y = Data(block_num).kinematics{trial_num}(:,4);
                speed = smooth(sqrt(vel_x.^2 + vel_y.^2));
                
                if from_move_start
                    if any(speed > thresh_speed)
                            idx_target_on = find(Data.target_on{trial_num}); % When the target came on (in bins)
                            bins_after_tgt = ceil(min_rxn_time/dt); % Min rxn time (in bins)
                            idx_possible = idx_target_on + bins_after_tgt;
                            bins_possible = speed*0;
                            bins_possible(idx_possible:end) = 1;
                            bins_thresh_cross = (speed > thresh_speed).*(bins_possible);
                            
                            if sum(bins_thresh_cross) < 1
                                continue
                            end
                            
                            bin_align = find(bins_thresh_cross,1); % For when speed threshold is reached; Need to push forward to around rxn time so as not to get end of current movement
                    else
                        continue
                    end
                end
                
                if from_cue_on
                    bin_align = find(Data.target_on{trial_num});
                end
                
                Data_struct(trial_idx).align_bin = bin_align;
            end
    end
    
    % Align data on whichever signal (target on, movement start, etc)
    [neural_data_aligned, aligned_bin] = align_data(Data_struct);
    
    % Group neural data by target direction
    neural_data_grouped = cell(length(target_loc),1);
    neural_data_mean = neural_data_grouped;
    x_fit = cell(length(target_loc),1);
    
    if plot_figs
%         figure
        figure('units','normalized','outerposition',[0 0 .75 1])
        subplot(1,2,2)
    end
    
    % Loop through target/reach directions
    for tgt_idx = 1:length(target_loc)
            trials_correct_target = find(abs(cond(trials,tgt_idx)) <= pi/8); % Note that trials indexes are a little weird here. This is a subset of the already selected trials.
        
        if isnan(time_window)
            neural_data_grouped{tgt_idx} = neural_data_aligned(trials_correct_target,:);
        else
            time_window_trial = time_window + aligned_bin;
            time_window_trial(time_window_trial<1) = [];
            time_window_trial(time_window_trial>size(neural_data_aligned,2)) = [];
            neural_data_grouped{tgt_idx} = neural_data_aligned(trials_correct_target,time_window_trial);
        end
        
        neural_data_mean{tgt_idx} = 100*nanmean(neural_data_grouped{tgt_idx},2);
        
        % Add some jitter
        x_plot = repmat(target_loc(tgt_idx),length(trials_correct_target),1) + .1*(rand(length(trials_correct_target),1)-.5);
        x_fit{tgt_idx} = repmat(target_loc(tgt_idx),length(trials_correct_target),1);
        
        if plot_figs
            scatter(x_plot,neural_data_mean{tgt_idx},'r')
            hold on
        end
    end
    
    FR_mean = nanmean(nanmean(neural_data_aligned))*100;
    
    % Arrange data for fit
    x_fit_all = cell2mat(x_fit);
    neural_data_all = cell2mat(neural_data_mean);
    
    % Fit basic GLM to estimate preferred direction for neuron
    X = [cos(x_fit_all) sin(x_fit_all)];
    [fit_param, dev, stats] = glmfit(X,neural_data_all,'poisson');
    PD(nrn_idx) = atan2(fit_param(3),fit_param(2));
    
    % Prepare plot for fit function
    x_plot_temp = [-pi:.01:pi]';
    x_plot_cos = cos(x_plot_temp);
    x_plot_sin = sin(x_plot_temp);
    y = glmval(fit_param, ...
        [x_plot_cos, x_plot_sin], ...
        'log');
    
    % Plot tuning data
    if plot_figs
        plot(x_plot_temp,y,'b')
        
        axis([-3.5 3.5 0 60])
        xlabel('Target direction (rad)')
        ylabel('Mean FR (Hz)')
        title([region ' neuron: ' num2str(nrn_num) ', center: ' num2str(PD(nrn_idx)*180/pi) ])
    end
    
    % Plot rasters
    [dir_reach,idx_sorted_trials] = sort(cell2mat(Data.reach_dir(trials)));
    [len_reach,idx_sorted_trials_len] = sort(cell2mat(Data.reach_len(trials)));
    dir_reach_unsorted = cell2mat(Data.reach_dir(trials));
    len_reach_unsorted = cell2mat(Data.reach_len(trials));
    
    % Apply sort to trials if necessary
    if isnan(time_window)
        if sort_trials
            neural_data_aligned = neural_data_aligned(idx_sorted_trials,:);
        end
        neural_data_cell{nrn_idx} = neural_data_aligned;
    else
        if sort_trials
            neural_data_aligned = neural_data_aligned(idx_sorted_trials,time_window_trial); % Sort trials by reach direction
        end
        neural_data_cell{nrn_idx} = neural_data_aligned;
    end
    
    if plot_figs
        subplot(1,2,1)
        imagesc(neural_data_aligned,[0 3])

        if isnan(time_window)
            title([region ' neuron: ' num2str(nrn_num) '. Mean FR: ' num2str(FR_mean) ', aligned to bin: ' num2str(aligned_bin)])
        else
            title([region ' neuron: ' num2str(nrn_num) '. Mean FR: ' num2str(FR_mean) ', aligned to bin: ' num2str(-time_window(1))])
        end

        hold off
    end
    
    disp(['Completed: ' region ' neuron ' num2str(nrn_num)])

end
